Only in tpm-tools-1.3.8-patched: autom4te.cache
Only in tpm-tools-1.3.8-patched: config.h
Only in tpm-tools-1.3.8-patched: config.log
Only in tpm-tools-1.3.8-patched: config.status
diff -ur tpm-tools-1.3.8/configure tpm-tools-1.3.8-patched/configure
--- tpm-tools-1.3.8/configure	2012-05-17 12:09:26.000000000 -0700
+++ tpm-tools-1.3.8-patched/configure	2013-12-23 09:17:50.454157764 -0800
@@ -764,7 +764,6 @@
 with_sysroot
 enable_libtool_lock
 enable_nls
-with_gnu_ld
 enable_rpath
 with_libiconv_prefix
 with_libintl_prefix
@@ -779,8 +778,7 @@
 LDFLAGS
 LIBS
 CPPFLAGS
-CPP
-CPPFLAGS'
+CPP'
 
 
 # Initialize some variables set by options.
Only in tpm-tools-1.3.8-patched/dist: tpm-tools.spec
Only in tpm-tools-1.3.8-patched/include: Makefile
diff -ur tpm-tools-1.3.8/include/tpm_utils.h tpm-tools-1.3.8-patched/include/tpm_utils.h
--- tpm-tools-1.3.8/include/tpm_utils.h	2011-08-17 05:20:35.000000000 -0700
+++ tpm-tools-1.3.8-patched/include/tpm_utils.h	2014-01-29 23:38:08.000000000 -0800
@@ -54,6 +54,8 @@
 #define TRUE (!FALSE)
 #endif
 
+#include "tpm_tspi.h"
+
 #define CMD_VERSION             PACKAGE_VERSION
 
 #define LOG_NONE                _("none")
@@ -89,8 +91,11 @@
 #endif
 char *_getPasswd( const char *a_pszPrompt, int *a_iLen, BOOL a_bConfirm, BOOL a_bUseUnicode);
 void  shredPasswd( char *a_pszPasswd );
+void shredByteArray( BYTE *a_pSecret, int iSecretLen );
 char *getReply( const char *a_pszPrompt, int a_iMaxLen );
 
+int hex2bytea( const char *a_pszHex, BYTE **a_pDecoded, int *a_iDecodedLen );
+
 extern int iLogLevel;
 extern BOOL useUnicode;
 
Only in tpm-tools-1.3.8-patched/lib: .deps
Only in tpm-tools-1.3.8-patched/lib: .libs
Only in tpm-tools-1.3.8-patched/lib: libtpm_tspi.la
Only in tpm-tools-1.3.8-patched/lib: libtpm_unseal.la
Only in tpm-tools-1.3.8-patched/lib: libtpm_utils.la
Only in tpm-tools-1.3.8-patched/lib: Makefile
Only in tpm-tools-1.3.8-patched/lib: tpm_log.lo
Only in tpm-tools-1.3.8-patched/lib: tpm_log.o
Only in tpm-tools-1.3.8-patched/lib: tpm_tspi.lo
Only in tpm-tools-1.3.8-patched/lib: tpm_tspi.o
Only in tpm-tools-1.3.8-patched/lib: tpm_unseal.lo
Only in tpm-tools-1.3.8-patched/lib: tpm_unseal.o
diff -ur tpm-tools-1.3.8/lib/tpm_utils.c tpm-tools-1.3.8-patched/lib/tpm_utils.c
--- tpm-tools-1.3.8/lib/tpm_utils.c	2010-09-30 10:28:09.000000000 -0700
+++ tpm-tools-1.3.8-patched/lib/tpm_utils.c	2014-01-29 23:32:56.000000000 -0800
@@ -146,6 +146,14 @@
 	}
 }
 
+void shredByteArray( BYTE *a_pSecret, int iSecretLen ) {
+
+	if ( a_pSecret ) {
+		memset( a_pSecret, 0, iSecretLen );
+		free( a_pSecret );
+	}
+}
+
 /*
  * You must free the memory passed back to you when you are finished.
  * Loop will always terminate by the second pass.
@@ -257,3 +265,33 @@
 out:
 	return pszReply;
 }
+
+/*
+ * You must free the memory allocated to a_pDecoded when you are done with it.
+ * Returns 0 for success, non-zero for failure.
+ */
+int hex2bytea( const char *a_pszHex, BYTE **a_pDecoded, int *a_iDecodedLen ) {
+	BYTE *pDecoded;
+	int iDecodedLen, iByte, i;
+	int iHexLen = strlen(a_pszHex);
+	if( iHexLen % 2 != 0 ) {
+		*a_pDecoded = NULL;
+		*a_iDecodedLen = 0;
+		return 1; // invalid length for hex
+	}
+	iDecodedLen = iHexLen / 2;
+	pDecoded = malloc( sizeof(char) * iDecodedLen );
+	for(i=0; i<iHexLen/2; i++) {
+		if( sscanf(a_pszHex+(i*2), "%2x", &iByte) != 1 ) {
+			free(pDecoded);
+			*a_pDecoded = NULL;
+			*a_iDecodedLen = 0;			
+			return 2; // invalid hex digit
+		}
+		pDecoded[i] = iByte & 0xFF;
+	}
+	*a_pDecoded = pDecoded;
+	*a_iDecodedLen = iDecodedLen;
+	return 0;
+}
+
Only in tpm-tools-1.3.8-patched/lib: tpm_utils.lo
Only in tpm-tools-1.3.8-patched/lib: tpm_utils.o
Only in tpm-tools-1.3.8-patched: libtool
Only in tpm-tools-1.3.8-patched/m4: Makefile
Only in tpm-tools-1.3.8-patched: Makefile
Only in tpm-tools-1.3.8-patched/man: Makefile
Only in tpm-tools-1.3.8-patched/man/man1: Makefile
Only in tpm-tools-1.3.8-patched/man/man3: Makefile
Only in tpm-tools-1.3.8-patched/man/man8: Makefile
Only in tpm-tools-1.3.8-patched/po: Makefile
Only in tpm-tools-1.3.8-patched/po: Makefile.in
Only in tpm-tools-1.3.8-patched/po: POTFILES
Only in tpm-tools-1.3.8-patched/src/cmds: .deps
Only in tpm-tools-1.3.8-patched/src/cmds: .libs
Only in tpm-tools-1.3.8-patched/src/cmds: Makefile
Only in tpm-tools-1.3.8-patched/src/cmds: tpm_sealdata
Only in tpm-tools-1.3.8-patched/src/cmds: tpm_sealdata.o
Only in tpm-tools-1.3.8-patched/src/cmds: tpm_unsealdata
Only in tpm-tools-1.3.8-patched/src/cmds: tpm_unsealdata.o
Only in tpm-tools-1.3.8-patched/src/data_mgmt: .deps
Only in tpm-tools-1.3.8-patched/src/data_mgmt: Makefile
Only in tpm-tools-1.3.8-patched/src: Makefile
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: .deps
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: .libs
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: Makefile
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_activate.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_changeauth.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_changeownerauth
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_clear
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_clearable.o
diff -ur tpm-tools-1.3.8/src/tpm_mgmt/tpm_clear.c tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_clear.c
--- tpm-tools-1.3.8/src/tpm_mgmt/tpm_clear.c	2010-09-30 10:28:09.000000000 -0700
+++ tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_clear.c	2014-03-02 16:13:13.000000000 -0800
@@ -26,6 +26,11 @@
 static BOOL bValue = FALSE;	//If true FORCE CLEAR
 static BOOL isWellKnown = FALSE;
 TSS_HCONTEXT hContext = 0;
+static BOOL askOwnerPass;
+static BOOL decodeHexPassword = FALSE;
+static BOOL useEnvironment = FALSE;
+static const char *ownerpass = NULL;
+static const char *ownerpassEnv = NULL;
 
 static inline TSS_RESULT tpmClearOwner(TSS_HTPM a_hTpm, BOOL a_bValue)
 {
@@ -41,6 +46,11 @@
 {
 	logCmdHelp(aCmd);
 	logUnicodeCmdOption();
+	logCmdOption("-o, --owner", _("Set owner secret"));
+	logCmdOption("-t, --use-env",
+		     _("TPM owner secret is in an environment variable "
+			   "whose name is given by -o, respectively"));
+	logCmdOption("-x, --use-hex", _("Use hex encoding for owner secret"));
 	logCmdOption("-f, --force", _("Use physical presence authorization."));
 	logCmdOption("-z, --well-known",
 		     _("Use 20 bytes of zeros (TSS_WELL_KNOWN_SECRET) as the TPM secret authorization data"));
@@ -50,6 +60,20 @@
 {
 
 	switch (aOpt) {
+	case 'o':
+		ownerpass = aArg;
+		if (!ownerpass)
+			askOwnerPass = TRUE;
+		else
+			askOwnerPass = FALSE;
+		isWellKnown = FALSE;
+		break;
+	case 't':
+		useEnvironment = TRUE;
+		break;
+	case 'x':
+		decodeHexPassword = TRUE;
+		break;
 	case 'f':
 		logDebug(_("Changing mode to use force authorization\n"));
 		bValue = TRUE;
@@ -69,11 +93,15 @@
 {
 
 	char *szTpmPasswd = NULL;
+	BYTE* pTpmPasswd = NULL;
 	int pswd_len;
 	TSS_HTPM hTpm;
 	TSS_HPOLICY hTpmPolicy;
 	int iRc = -1;
 	struct option opts[] = {
+			{"owner"   , required_argument, NULL, 'o'},
+			{"use-env",          no_argument, NULL, 't'},
+			{"use-hex",          no_argument, NULL, 'x'},
 			{"force", no_argument, NULL, 'f'},
 			{"well-known", no_argument, NULL, 'z'},
 	};
@@ -82,7 +110,7 @@
         initIntlSys();
 
 	if (genericOptHandler
-	    (argc, argv, "fz", opts, sizeof(opts) / sizeof(struct option),
+	    (argc, argv, "o:txfz", opts, sizeof(opts) / sizeof(struct option),
 	     parse, help) != 0)
 		goto out;
 
@@ -100,19 +128,50 @@
 			szTpmPasswd = (char *)well_known;
 			pswd_len = sizeof(well_known);
 		}else{
-			szTpmPasswd = GETPASSWD(_("Enter owner password: "), &pswd_len, FALSE);
-			if (!szTpmPasswd) {
-				logMsg(_("Failed to get password\n"));
-				goto out_close;
+			if (askOwnerPass) {
+
+				szTpmPasswd = GETPASSWD(_("Enter owner password: "), &pswd_len, FALSE);
+				if (!szTpmPasswd) {
+					logMsg(_("Failed to get password\n"));
+					goto out_close;
+				}
+				ownerpass = szTpmPasswd;
+			}
+				
+			if (ownerpass && !askOwnerPass && useEnvironment) {
+				ownerpassEnv = ownerpass;
+				ownerpass = getenv(ownerpassEnv);
+				if (!ownerpass) {
+					logMsg(_("%s is not defined\n"), ownerpassEnv);
+					goto out_close;
+				}
 			}
+			
 		}
 
 		if (policyGet(hTpm, &hTpmPolicy) != TSS_SUCCESS)
 			goto out_close;
 
-		if (policySetSecret(hTpmPolicy, pswd_len,
-				    (BYTE *)szTpmPasswd) != TSS_SUCCESS)
-			goto out_close;
+		if( isWellKnown ) {
+			if (policySetSecret(hTpmPolicy, pswd_len,
+						(BYTE *)szTpmPasswd) != TSS_SUCCESS)
+				goto out_close;
+		}
+		else if( decodeHexPassword ) {
+				if( hex2bytea(ownerpass, &pTpmPasswd, &pswd_len) != 0 ) {
+					logMsg(_("Invalid hex TPM owner secret\n"));
+					goto out_close;
+				}
+				if( Tspi_Policy_SetSecret(hTpmPolicy, TSS_SECRET_MODE_PLAIN, pswd_len,
+							pTpmPasswd) != TSS_SUCCESS)
+					goto out_close;
+		}
+		else {
+			if( pswd_len < 0 )
+				pswd_len = strlen(ownerpass);
+			if (policySetSecret(hTpmPolicy, pswd_len, (BYTE *)ownerpass) != TSS_SUCCESS)
+				goto out_close;
+		}
 	}
 	//Setup complete attempt command
 	if (tpmClearOwner(hTpm, bValue) != TSS_SUCCESS)
@@ -128,6 +187,8 @@
       out_close:
 	if (szTpmPasswd && !isWellKnown)
 		shredPasswd(szTpmPasswd);
+	if( pTpmPasswd )
+		shredByteArray(pTpmPasswd, pswd_len);
 
 	contextClose(hContext);
 
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_clear.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_createek
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_createek.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_enable.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_getpubek
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_getpubek.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvcommon.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvdefine
diff -ur tpm-tools-1.3.8/src/tpm_mgmt/tpm_nvdefine.c tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_nvdefine.c
--- tpm-tools-1.3.8/src/tpm_mgmt/tpm_nvdefine.c	2012-05-17 10:49:58.000000000 -0700
+++ tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_nvdefine.c	2014-01-30 00:18:41.000000000 -0800
@@ -32,9 +32,11 @@
 static unsigned int nvperm;
 static unsigned int nvsize;
 static const char *ownerpass;
+static const char *ownerpassEnv;
 static BOOL ownerWellKnown;
 static BOOL askOwnerPass;
 static const char *datapass;
+static const char *datapassEnv;
 static BOOL dataWellKnown;
 static BOOL askDataPass;
 static int end;
@@ -43,7 +45,8 @@
 static UINT32 selectedPcrsReadLen = 0;
 static UINT32 selectedPcrsWriteLen = 0;
 static const char *filename;
-
+static BOOL decodeHexPassword = FALSE;
+static BOOL useEnvironment = FALSE;
 TSS_HCONTEXT hContext = 0;
 
 
@@ -83,6 +86,14 @@
 		ownerWellKnown = FALSE;
 		break;
 
+	case 't':
+		useEnvironment = TRUE;
+		break;
+		
+	case 'x':
+		decodeHexPassword = TRUE;
+		break;
+		
 	case 'y':
 		ownerWellKnown = TRUE;
 		ownerpass = NULL;
@@ -136,6 +147,11 @@
 {
 	logCmdHelp(aCmd);
 	logUnicodeCmdOption();
+	logCmdOption("-t, --use-env",
+		     _("TPM owner secret and NVRAM area secret are in environment variables "
+			   "whose names are given by -o and -a, respectively"));
+	logCmdOption("-x, --use-hex",
+		     _("Use hex encoding for TPM owner secret or NVRAM area secret"));
 	logCmdOption("-y, --owner-well-known",
 		     _("Use 20 bytes of zeros (TSS_WELL_KNOWN_SECRET) as the "
 		       "TPM owner secret"));
@@ -255,6 +271,8 @@
 		{"pwdo"            , optional_argument, NULL, 'o'},
 		{"pwda"            , optional_argument, NULL, 'a'},
 		{"use-unicode"     ,       no_argument, NULL, 'u'},
+		{"use-env",                no_argument, NULL, 't'},
+		{"use-hex",                no_argument, NULL, 'x'},
 		{"data-well-known" ,       no_argument, NULL, 'z'},
 		{"owner-well-known",       no_argument, NULL, 'y'},
 		{NULL              ,       no_argument, NULL, 0},
@@ -262,11 +280,13 @@
 	TSS_FLAG initFlag = TSS_PCRS_STRUCT_INFO_SHORT;
 	UINT32 localityValue = TPM_LOC_ZERO | TPM_LOC_ONE | TPM_LOC_TWO |
 			       TPM_LOC_THREE | TPM_LOC_FOUR;
-
+	BYTE* pTpmPasswd = NULL;
+	BYTE* pAuthPasswd = NULL;
+	int iTpmPasswdLen, iAuthPasswdLen;
 	initIntlSys();
 
 	if (genericOptHandler
-		    (argc, argv, "i:s:p:o:a:r:w:f:yzu", hOpts,
+		    (argc, argv, "i:s:p:o:a:r:w:f:txyzu", hOpts,
 		     sizeof(hOpts) / sizeof(struct option), parse, help) != 0)
 		goto out;
 
@@ -315,15 +335,32 @@
 		}
 	}
 
+	if (ownerpass && !askOwnerPass && useEnvironment) {
+		ownerpassEnv = ownerpass;
+		ownerpass = getenv(ownerpassEnv);
+		if (!ownerpass) {
+			logError(_("%s is not defined\n"), ownerpassEnv);
+			goto out_close;
+		}
+	}
+	
 	if (ownerpass || ownerWellKnown) {
 		if (policyGet(hTpm, &hTpmPolicy) != TSS_SUCCESS)
 			goto out_close;
-		if (ownerpass) {
+		if (ownerpass && decodeHexPassword) {
+			if( hex2bytea(ownerpass, &pTpmPasswd, &iTpmPasswdLen) != 0 ) {
+				logError(_("Invalid hex owner secret\n"));
+				goto out_close;
+			}
+			if( Tspi_Policy_SetSecret(hTpmPolicy, TSS_SECRET_MODE_PLAIN, iTpmPasswdLen,
+						pTpmPasswd) != TSS_SUCCESS)
+				goto out_close;
+		} else if (ownerpass) {
 			if (opswd_len < 0)
 				opswd_len = strlen(ownerpass);
 			if (policySetSecret(hTpmPolicy, opswd_len,
-					    (BYTE *)ownerpass) != TSS_SUCCESS)
-				goto out_close;
+						(BYTE *)ownerpass) != TSS_SUCCESS)
+					goto out_close;
 		} else {
 			if (policySetSecret(hTpmPolicy, TCPA_SHA1_160_HASH_LEN,
 					    (BYTE *)well_known_secret) != TSS_SUCCESS)
@@ -340,18 +377,35 @@
 		}
 	}
 
+	if (datapass && !askDataPass && useEnvironment) {
+		datapassEnv = datapass;
+		datapass = getenv(datapassEnv);
+		if (!datapass) {
+			logError(_("%s is not defined\n"), datapassEnv);
+			goto out_close;
+		}
+	}
+	
 	if (datapass || dataWellKnown) {
 		if (contextCreateObject
 		    (hContext, TSS_OBJECT_TYPE_POLICY, TSS_POLICY_USAGE,
 		     &hDataPolicy) != TSS_SUCCESS)
 			goto out_close;
 
-		if (datapass) {
+		if (datapass && decodeHexPassword) {
+			if( hex2bytea(datapass, &pAuthPasswd, &iAuthPasswdLen) != 0 ) {
+				logError(_("Invalid hex auth secret\n"));
+				goto out_close;
+			}
+			if( Tspi_Policy_SetSecret(hDataPolicy, TSS_SECRET_MODE_PLAIN, iAuthPasswdLen,
+						pAuthPasswd) != TSS_SUCCESS)
+				goto out_close;
+		} else if (datapass) {
 			if (dpswd_len < 0)
 				dpswd_len = strlen(datapass);
 			if (policySetSecret(hDataPolicy, dpswd_len,
-				    (BYTE *)datapass) != TSS_SUCCESS)
-				goto out_close;
+						(BYTE *)datapass) != TSS_SUCCESS)
+					goto out_close;
 		} else {
 			if (policySetSecret(hDataPolicy, TCPA_SHA1_160_HASH_LEN,
 				    (BYTE *)well_known_secret) != TSS_SUCCESS)
@@ -476,5 +530,10 @@
 	contextClose(hContext);
 
       out:
+	if( pTpmPasswd )
+		shredByteArray(pTpmPasswd, iTpmPasswdLen);
+	if( pAuthPasswd )
+		shredByteArray(pAuthPasswd, iAuthPasswdLen);
+		
 	return iRc;
 }
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvdefine.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvinfo
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvinfo.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvread
diff -ur tpm-tools-1.3.8/src/tpm_mgmt/tpm_nvread.c tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_nvread.c
--- tpm-tools-1.3.8/src/tpm_mgmt/tpm_nvread.c	2011-08-17 05:20:35.000000000 -0700
+++ tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_nvread.c	2014-01-30 00:14:42.000000000 -0800
@@ -35,7 +35,10 @@
 static const char *filename;
 static BOOL passWellKnown;
 static const char *password;
+static const char *passwordEnv;
 static BOOL askPassword;
+static BOOL decodeHexPassword = FALSE;
+static BOOL useEnvironment = FALSE;
 
 TSS_HCONTEXT hContext = 0;
 
@@ -76,6 +79,14 @@
 		passWellKnown =  FALSE;
 		break;
 
+	case 't':
+		useEnvironment = TRUE;
+		break;
+		
+	case 'x':
+		decodeHexPassword = TRUE;
+		break;
+		
 	case 'z':
 		password = NULL;
 		passWellKnown =  TRUE;
@@ -123,6 +134,11 @@
 {
 	logCmdHelp(aCmd);
 	logUnicodeCmdOption();
+	logCmdOption("-t, --use-env",
+		     _("TPM owner secret and NVRAM area secret are in environment variables "
+			   "whose names are given by -o and -a, respectively"));
+	logCmdOption("-x, --use-hex",
+		     _("Use hex encoding for TPM owner secret or NVRAM area secret"));
 	logCmdOption("-z, --well-known",
 		     _("Use 20 bytes of zeros (TSS_WELL_KNOWN_SECRET) as the TPM secret authorization data"));
 	logCmdOption("-p, --password",
@@ -156,16 +172,20 @@
 		{"filename"   , required_argument, NULL, 'f'},
 		{"password"   , optional_argument, NULL, 'p'},
 		{"use-unicode",       no_argument, NULL, 'u'},
+		{"use-env",           no_argument, NULL, 't'},
+		{"use-hex",           no_argument, NULL, 'x'},
 		{"well-known" ,       no_argument, NULL, 'z'},
 		{NULL         ,       no_argument, NULL, 0},
 	};
 	int fd = -1;
 	ssize_t written;
+	BYTE* pPasswd = NULL;
+	int iPasswdLen;
 
 	initIntlSys();
 
 	if (genericOptHandler
-		    (argc, argv, "i:s:n:f:p::zu", hOpts,
+		    (argc, argv, "i:s:n:f:p::txzu", hOpts,
 		     sizeof(hOpts) / sizeof(struct option), parse, help) != 0)
 		goto out;
 
@@ -203,16 +223,33 @@
 		}
 	}
 
+	if (password && !askPassword && useEnvironment) {
+		passwordEnv = password;
+		password = getenv(passwordEnv);
+		if (!password) {
+			logError(_("%s is not defined\n"), passwordEnv);
+			goto out_close;
+		}
+	}
+	
 	if (password || passWellKnown) {
 		if (policyGet(hTpm, &hTpmPolicy) != TSS_SUCCESS)
 			goto out_close;
 
-		if (password) {
+		if (password && decodeHexPassword) {
+			if( hex2bytea(password, &pPasswd, &iPasswdLen) != 0 ) {
+				logError(_("Invalid hex secret\n"));
+				goto out_close;
+			}
+			if( Tspi_Policy_SetSecret(hTpmPolicy, TSS_SECRET_MODE_PLAIN, iPasswdLen,
+						pPasswd) != TSS_SUCCESS)
+				goto out_close;
+		} else if (password) {
 			if (pswd_len < 0)
 				pswd_len = strlen(password);
 			if (policySetSecret(hTpmPolicy, pswd_len,
-					    (BYTE *)password) != TSS_SUCCESS)
-				goto out_close;
+							(BYTE *)password) != TSS_SUCCESS)
+					goto out_close;
 		} else {
 			if (policySetSecret(hTpmPolicy, TCPA_SHA1_160_HASH_LEN,
 					    (BYTE *)well_known_secret) != TSS_SUCCESS)
@@ -224,7 +261,11 @@
 		     &hDataPolicy) != TSS_SUCCESS)
 			goto out_close;
 
-		if (password) {
+		if (password && decodeHexPassword) {
+			if( Tspi_Policy_SetSecret(hDataPolicy, TSS_SECRET_MODE_PLAIN, iPasswdLen,
+						pPasswd) != TSS_SUCCESS)
+				goto out_close;
+		} else if (password) {
 			if (policySetSecret(hDataPolicy, pswd_len,
 					    (BYTE *)password) != TSS_SUCCESS)
 				goto out_close;
@@ -306,6 +347,8 @@
       out:
 	free(rgbDataRead);
 	freeNVDataPublic(nvpub);
+	if( pPasswd )
+		shredByteArray(pPasswd, iPasswdLen);
 
 	return iRc;
 }
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvread.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvrelease
diff -ur tpm-tools-1.3.8/src/tpm_mgmt/tpm_nvrelease.c tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_nvrelease.c
--- tpm-tools-1.3.8/src/tpm_mgmt/tpm_nvrelease.c	2011-08-17 05:20:35.000000000 -0700
+++ tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_nvrelease.c	2014-01-30 00:20:38.000000000 -0800
@@ -27,8 +27,11 @@
 
 static unsigned int nvindex;
 static const char *ownerpass;
+static const char *ownerpassEnv;
 static BOOL ownerWellKnown;
 static BOOL askOwnerPass;
+static BOOL decodeHexPassword = FALSE;
+static BOOL useEnvironment = FALSE;
 TSS_HCONTEXT hContext = 0;
 
 
@@ -51,6 +54,14 @@
 		ownerWellKnown = FALSE;
 		break;
 
+	case 't':
+		useEnvironment = TRUE;
+		break;
+		
+	case 'x':
+		decodeHexPassword = TRUE;
+		break;
+		
 	case 'y':
 		ownerWellKnown = TRUE;
 		askOwnerPass = FALSE;
@@ -71,6 +82,11 @@
 {
 	logCmdHelp(aCmd);
 	logUnicodeCmdOption();
+	logCmdOption("-t, --use-env",
+		     _("TPM owner secret and NVRAM area secret are in environment variables "
+			   "whose names are given by -o and -a, respectively"));
+	logCmdOption("-x, --use-hex",
+		     _("Use hex encoding for TPM owner secret or NVRAM area secret"));
 	logCmdOption("-y, --owner-well-known",
 		     _("Use 20 bytes of zeros (TSS_WELL_KNOWN_SECRET) as the TPM owner password"));
 	logOwnerPassCmdOption();
@@ -90,14 +106,18 @@
 	struct option hOpts[] = {
 		{"index"           , required_argument, NULL, 'i'},
 		{"pwdo"            , optional_argument, NULL, 'o'},
+		{"use-env",                no_argument, NULL, 't'},
+		{"use-hex",                no_argument, NULL, 'x'},
 		{"owner-well-known",       no_argument, NULL, 'y'},
 		{NULL              ,       no_argument, NULL, 0},
 	};
+	BYTE* pTpmPasswd = NULL;
+	int iTpmPasswdLen;
 
 	initIntlSys();
 
 	if (genericOptHandler
-		    (argc, argv, "i:o::y", hOpts,
+		    (argc, argv, "i:o::txy", hOpts,
 		     sizeof(hOpts) / sizeof(struct option), parse, help) != 0)
 		goto out;
 
@@ -127,16 +147,32 @@
 		}
 	}
 
+	if (ownerpass && !askOwnerPass && useEnvironment) {
+		ownerpassEnv = ownerpass;
+		ownerpass = getenv(ownerpassEnv);
+		if (!ownerpass) {
+			logError(_("%s is not defined\n"), ownerpassEnv);
+			goto out_close;
+		}
+	}
+	
 	if (ownerpass || ownerWellKnown) {
 		if (policyGet(hTpm, &hTpmPolicy) != TSS_SUCCESS)
 			goto out_close;
-		if (ownerpass) {
+		if (ownerpass && decodeHexPassword) {
+			if( hex2bytea(ownerpass, &pTpmPasswd, &iTpmPasswdLen) != 0 ) {
+				logError(_("Invalid hex SRK secret\n"));
+				goto out_close;
+			}
+			if( Tspi_Policy_SetSecret(hTpmPolicy, TSS_SECRET_MODE_PLAIN, iTpmPasswdLen,
+						pTpmPasswd) != TSS_SUCCESS)
+				goto out_close;
+		} else if (ownerpass) {
 			if (pswd_len < 0)
 				pswd_len = strlen(ownerpass);
-
 			if (policySetSecret(hTpmPolicy, pswd_len,
 					    (BYTE *)ownerpass) != TSS_SUCCESS)
-				goto out_close;
+					goto out_close;
 		} else {
 			if (policySetSecret(hTpmPolicy, TCPA_SHA1_160_HASH_LEN,
 					    (BYTE *)well_known_secret) != TSS_SUCCESS)
@@ -174,5 +210,8 @@
 	contextClose(hContext);
 
       out:
+		if( pTpmPasswd )
+			shredByteArray(pTpmPasswd, iTpmPasswdLen);
+			
 	return iRc;
 }
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvrelease.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvwrite
diff -ur tpm-tools-1.3.8/src/tpm_mgmt/tpm_nvwrite.c tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_nvwrite.c
--- tpm-tools-1.3.8/src/tpm_mgmt/tpm_nvwrite.c	2011-08-17 05:20:35.000000000 -0700
+++ tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_nvwrite.c	2014-01-30 00:19:31.000000000 -0800
@@ -38,8 +38,10 @@
 static BOOL passWellKnown;
 static BOOL askPassword;
 static const char *password;
+static const char *passwordEnv;
 static char *data;
-
+static BOOL decodeHexPassword = FALSE;
+static BOOL useEnvironment = FALSE;
 TSS_HCONTEXT hContext = 0;
 
 
@@ -96,6 +98,14 @@
 		passWellKnown =  FALSE;
 		break;
 
+	case 't':
+		useEnvironment = TRUE;
+		break;
+		
+	case 'x':
+		decodeHexPassword = TRUE;
+		break;
+		
 	case 'z':
 		password = NULL;
 		passWellKnown =  TRUE;
@@ -116,6 +126,11 @@
 {
 	logCmdHelp(aCmd);
 	logUnicodeCmdOption();
+	logCmdOption("-t, --use-env",
+		     _("TPM owner secret and NVRAM area secret are in environment variables "
+			   "whose names are given by -o and -a, respectively"));
+	logCmdOption("-x, --use-hex",
+		     _("Use hex encoding for TPM owner secret or NVRAM area secret"));
 	logCmdOption("-z, --well-known",
 		     _("Use 20 bytes of zeros (TSS_WELL_KNOWN_SECRET) as the TPM secret authorization data"));
 	logCmdOption("-p, --password",
@@ -155,17 +170,21 @@
 		{"fillvalue"  , required_argument, NULL, 'm'},
 		{"password"   , optional_argument, NULL, 'p'},
 		{"use-unicode",       no_argument, NULL, 'u'},
+		{"use-env",           no_argument, NULL, 't'},
+		{"use-hex",           no_argument, NULL, 'x'},
 		{"well-known" ,       no_argument, NULL, 'z'},
 		{NULL	 ,       no_argument, NULL, 0},
 	};
 	struct stat statbuf;
 	int fd = -1;
 	ssize_t read_bytes;
+	BYTE* pPasswd = NULL;
+	int iPasswdLen;
 
 	initIntlSys();
 
 	if (genericOptHandler
-		    (argc, argv, "i:s:n:d:f:m:p::zu", hOpts,
+		    (argc, argv, "i:s:n:d:f:m:p::txzu", hOpts,
 		     sizeof(hOpts) / sizeof(struct option), parse, help) != 0)
 		goto out;
 
@@ -261,11 +280,29 @@
 			goto out_close;
 		}
 	}
+	
+	if (password && !askPassword && useEnvironment) {
+		passwordEnv = password;
+		password = getenv(passwordEnv);
+		if (!password) {
+			logError(_("%s is not defined\n"), passwordEnv);
+			goto out_close;
+		}
+	}
+	
 	if (password || passWellKnown) {
 		if (policyGet(hTpm, &hTpmPolicy) != TSS_SUCCESS)
 			goto out_close;
 
-		if (password) {
+		if (password && decodeHexPassword) {
+			if( hex2bytea(password, &pPasswd, &iPasswdLen) != 0 ) {
+				logError(_("Invalid hex secret\n"));
+				goto out_close;
+			}
+			if( Tspi_Policy_SetSecret(hTpmPolicy, TSS_SECRET_MODE_PLAIN, iPasswdLen,
+						pPasswd) != TSS_SUCCESS)
+				goto out_close;
+		} else if (password) {
 			if (pswd_len < 0)
 				pswd_len = strlen(password);
 			if (policySetSecret(hTpmPolicy, strlen(password),
@@ -282,8 +319,12 @@
 		     &hDataPolicy) != TSS_SUCCESS)
 			goto out_close;
 
-		if (password) {
-			if (policySetSecret(hDataPolicy, strlen(password),
+		if (password && decodeHexPassword) {
+			if( Tspi_Policy_SetSecret(hDataPolicy, TSS_SECRET_MODE_PLAIN, iPasswdLen,
+						pPasswd) != TSS_SUCCESS)
+				goto out_close;
+		} else if (password) {
+			if (policySetSecret(hDataPolicy, pswd_len,
 					    (BYTE *)password) != TSS_SUCCESS)
 				goto out_close;
 		} else {
@@ -356,12 +397,14 @@
       out_close_obj:
 	contextCloseObject(hContext, nvObject);
 
-      out_close:
+      out_close:		
 	contextClose(hContext);
 
       out:
 	free(rgbDataToWrite);
 	freeNVDataPublic(nvpub);
+	if( pPasswd )
+		shredByteArray(pPasswd, iPasswdLen);
 
 	return iRc;
 }
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_nvwrite.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_ownable.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_present.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_reset
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_resetdalock
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_resetdalock.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_reset.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_restrictpubek
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_restrictpubek.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_restrictsrk
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_restrictsrk.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_revokeek
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_revokeek.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_selftest
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_selftest.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_setactive
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_setclearable
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_setenable
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_setoperatorauth
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_setoperatorauth.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_setownable
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_setpresence
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_startup
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_startup.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_takeownership
diff -ur tpm-tools-1.3.8/src/tpm_mgmt/tpm_takeownership.c tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_takeownership.c
--- tpm-tools-1.3.8/src/tpm_mgmt/tpm_takeownership.c	2010-09-30 10:28:09.000000000 -0700
+++ tpm-tools-1.3.8-patched/src/tpm_mgmt/tpm_takeownership.c	2014-01-30 00:52:06.000000000 -0800
@@ -26,23 +26,63 @@
 {
 	logCmdHelp(aCmd);
 	logUnicodeCmdOption();
+	logCmdOption("-o, --owner", _("Set owner secret"));
+	logCmdOption("-s, --srk", _("Set the SRK secret"));
+	logCmdOption("-t, --use-env",
+		     _("TPM owner secret and NVRAM area secret are in environment variables "
+			   "whose names are given by -o and -a, respectively"));
+	logCmdOption("-x, --use-hex", _("Use hex encoding for owner secret and SRK secret"));
 	logCmdOption("-y, --owner-well-known", _("Set the owner secret to all zeros (20 bytes of zeros)."));
 	logCmdOption("-z, --srk-well-known", _("Set the SRK secret to all zeros (20 bytes of zeros)."));
 }
 
 static BOOL ownerWellKnown = FALSE;
 static BOOL srkWellKnown = FALSE;
+static BOOL askOwnerPass;
+static BOOL askSrkPass;
+static BOOL decodeHexPassword = FALSE;
+static BOOL useEnvironment = FALSE;
 TSS_HCONTEXT hContext = 0;
+static const char *ownerpass = NULL;
+static const char *srkpass = NULL;
+static const char *ownerpassEnv = NULL;
+static const char *srkpassEnv = NULL;
 
 static int parse(const int aOpt, const char *aArg)
 {
 
 	switch (aOpt) {
+	case 's':
+		srkpass = aArg;
+		if (!srkpass)
+			askSrkPass = TRUE;
+		else
+			askSrkPass = FALSE;
+		srkWellKnown = FALSE;
+		break;
+	case 'o':
+		ownerpass = aArg;
+		if (!ownerpass)
+			askOwnerPass = TRUE;
+		else
+			askOwnerPass = FALSE;
+		ownerWellKnown = FALSE;
+		break;
+	case 't':
+		useEnvironment = TRUE;
+		break;
+	case 'x':
+		decodeHexPassword = TRUE;
+		break;
 	case 'y':
 		ownerWellKnown = TRUE;
+		ownerpass = NULL;
+		askOwnerPass = FALSE;
 		break;
 	case 'z':
 		srkWellKnown = TRUE;
+		srkpass = NULL;
+		askSrkPass = FALSE;
 		break;
 	default:
 		return -1;
@@ -63,16 +103,23 @@
 int main(int argc, char **argv)
 {
 
-	char *szTpmPasswd = NULL;
-	char *szSrkPasswd = NULL;
 	int tpm_len, srk_len;
 	TSS_HTPM hTpm;
 	TSS_HKEY hSrk;
 	TSS_FLAG fSrkAttrs;
 	TSS_HPOLICY hTpmPolicy, hSrkPolicy;
+	char *szTpmPasswd = NULL;
+	char *szSrkPasswd = NULL;
+	BYTE* pTpmPasswd = NULL;
+	BYTE* pSrkPasswd = NULL;
+	int iTpmPasswdLen, iSrkPasswdLen;
 	int iRc = -1;
 	BYTE well_known_secret[] = TSS_WELL_KNOWN_SECRET;
 	struct option opts[] = {
+	{"owner"   , required_argument, NULL, 'o'},
+	{"srk"     , required_argument, NULL, 's'},
+	{"use-env",          no_argument, NULL, 't'},
+	{"use-hex",          no_argument, NULL, 'x'},
 	{"owner-well-known", no_argument, NULL, 'y'},
 	{"srk-well-known", no_argument, NULL, 'z'},
 	};
@@ -80,25 +127,27 @@
 	initIntlSys();
 
 	if (genericOptHandler
-	    (argc, argv, "yz", opts, sizeof(opts) / sizeof(struct option),
+	    (argc, argv, "o:s:txyz", opts, sizeof(opts) / sizeof(struct option),
 	     parse, help) != 0)
 		goto out;
 
 	if (contextCreate(&hContext) != TSS_SUCCESS)
 		goto out;
 
-	if (!ownerWellKnown) {
+	if (askOwnerPass) {
 		// Prompt for owner password
 		szTpmPasswd = GETPASSWD(_("Enter owner password: "), &tpm_len, TRUE);
 		if (!szTpmPasswd)
 			goto out;
+		ownerpass = szTpmPasswd;
 	}
 
-	if (!srkWellKnown) {
+	if (askSrkPass) {
 		// Prompt for srk password
 		szSrkPasswd = GETPASSWD(_("Enter SRK password: "), &srk_len, TRUE);
 		if (!szSrkPasswd)
 			goto out;
+		srkpass = szSrkPasswd;
 	}
 
 	if (contextConnect(hContext) != TSS_SUCCESS)
@@ -110,13 +159,34 @@
 	if (policyGet(hTpm, &hTpmPolicy) != TSS_SUCCESS)
 		goto out_close;
 
+	if (ownerpass && !askOwnerPass && useEnvironment) {
+		ownerpassEnv = ownerpass;
+		ownerpass = getenv(ownerpassEnv);
+		if (!ownerpass) {
+			logError(_("%s is not defined\n"), ownerpassEnv);
+			goto out_close;
+		}
+	}
+		
 	if (ownerWellKnown) {
 		tpm_len = TCPA_SHA1_160_HASH_LEN;
 		if (policySetSecret(hTpmPolicy, tpm_len, well_known_secret) != TSS_SUCCESS)
 			goto out_obj_close;
+	} else if( decodeHexPassword ) {
+				if( hex2bytea(ownerpass, &pTpmPasswd, &iTpmPasswdLen) != 0 ) {
+					logError(_("Invalid hex TPM owner secret\n"));
+					goto out_close;
+				}
+				if( Tspi_Policy_SetSecret(hTpmPolicy, TSS_SECRET_MODE_PLAIN, iTpmPasswdLen,
+							pTpmPasswd) != TSS_SUCCESS)
+					goto out_close;
 	} else {
-		if (policySetSecret(hTpmPolicy, tpm_len, (BYTE *)szTpmPasswd) != TSS_SUCCESS)
+	
+			if( tpm_len < 0 )
+				tpm_len = strlen(ownerpass);
+		if (policySetSecret(hTpmPolicy, tpm_len, (BYTE *)ownerpass) != TSS_SUCCESS)
 			goto out_close;
+			
 	}
 
 	fSrkAttrs = TSS_KEY_TSP_SRK | TSS_KEY_AUTHORIZATION;
@@ -129,13 +199,37 @@
 	if (policyGet(hSrk, &hSrkPolicy) != TSS_SUCCESS)
 		goto out_obj_close;
 
+	if (srkpass && !askSrkPass && useEnvironment) {
+		srkpassEnv = srkpass;
+		srkpass = getenv(srkpassEnv);
+		if (!srkpass) {
+			logError(_("%s is not defined\n"), srkpassEnv);
+			goto out_close;
+		}
+	}
+		
 	if (srkWellKnown) {
 		srk_len = TCPA_SHA1_160_HASH_LEN;
 		if (policySetSecret(hSrkPolicy, srk_len, well_known_secret) != TSS_SUCCESS)
 			goto out_obj_close;
 	} else {
-		if (policySetSecret(hSrkPolicy, srk_len, (BYTE *)szSrkPasswd) != TSS_SUCCESS)
+			if( decodeHexPassword ) {
+				if( hex2bytea(srkpass, &pSrkPasswd, &iSrkPasswdLen) != 0 ) {
+					logError(_("Invalid hex SRK secret\n"));
+					goto out_close;
+				}
+				if( Tspi_Policy_SetSecret(hSrkPolicy, TSS_SECRET_MODE_PLAIN, iSrkPasswdLen,
+							pSrkPasswd) != TSS_SUCCESS)
+					goto out_close;
+			}
+			else {
+			
+			if( srk_len < 0 )
+				srk_len = strlen(srkpass);
+		if (policySetSecret(hSrkPolicy, srk_len, (BYTE *)srkpass) != TSS_SUCCESS)
 			goto out_obj_close;
+			
+			}
 	}
 
 	if (tpmTakeOwnership(hTpm, hSrk) != TSS_SUCCESS)
@@ -157,5 +251,11 @@
 		if (szSrkPasswd)
 			shredPasswd(szSrkPasswd);
 
+		if( pTpmPasswd )
+			shredByteArray(pTpmPasswd, iTpmPasswdLen);
+			
+		if( pSrkPasswd )
+			shredByteArray(pSrkPasswd, iSrkPasswdLen);
+			
 	return iRc;
 }
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_takeownership.o
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_version
Only in tpm-tools-1.3.8-patched/src/tpm_mgmt: tpm_version.o
Only in tpm-tools-1.3.8-patched: stamp-h1
